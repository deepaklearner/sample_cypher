Great question â€” if a record violates **both Rule 1 and Rule 2**, you need to decide how to handle that:

---

### âœ… 3 Common Options:

| Option | Behavior                                                                | Example Reason Field                                            |
| ------ | ----------------------------------------------------------------------- | --------------------------------------------------------------- |
| 1      | **Keep only the first reason found**                                    | `"Contractor label present but recordType is not 'Conversion'"` |
| 2      | **Track all reasons per employee** (e.g., as a list or combined string) | `"Contractor label...; employmentStatus in ['A','L']..."`       |
| 3      | **One row per reason** (duplicate employee numbers allowed)             | Multiple rows for the same `employeeNumber`                     |

---

### âœ… Recommended: **Option 2** (combine reasons per employee)

Itâ€™s the most informative and compact format for logs.

---

### ðŸ”§ Updated `check_new_rejections()` â€” Combine Reasons Per Employee

```python
def check_new_rejections(df, label_fields=('Contractor', 'Active', 'OnLeave')):
    """
    Applies rejection rules and returns mismatch_df with columns:
    - employeeNumber
    - Reason (combined if multiple)
    """
    reasons = {}

    # --- Rule 1: Contractor + not Conversion ---
    contractor_mask = df['labels'].apply(lambda labels: 'Contractor' in labels)
    contractor_issue = df[contractor_mask & (df['recordType'] != 'Conversion')]
    for emp_num in contractor_issue['employeeNumber']:
        reasons.setdefault(emp_num, []).append("Contractor label present but recordType is not 'Conversion'")

    # --- Rule 2: A/L status missing Active/OnLeave label ---
    status_mismatch = df[
        df['employmentStatus'].isin(['A', 'L']) &
        (~df['labels'].apply(lambda labels: any(l in ['Active', 'OnLeave'] for l in labels)))
    ]
    for emp_num in status_mismatch['employeeNumber']:
        reasons.setdefault(emp_num, []).append("employmentStatus in ['A','L'] but missing 'Active'/'OnLeave' label in Neo4j")

    # --- Rule 3: Hire date in the future ---
    if 'hireDate' in df.columns:
        df['hireDate'] = pd.to_datetime(df['hireDate'], errors='coerce')
        future_hires = df[df['hireDate'] > pd.Timestamp.today()]
        for emp_num in future_hires['employeeNumber']:
            reasons.setdefault(emp_num, []).append("Hire date is in the future")

    # --- Build DataFrame ---
    mismatch_df = pd.DataFrame([
        {'employeeNumber': emp_num, 'Reason': '; '.join(reason_list)}
        for emp_num, reason_list in reasons.items()
    ])

    return mismatch_df
```

---

### âœ… Output Format Example:

| employeeNumber | Reason                                                                 |
| -------------- | ---------------------------------------------------------------------- |
| 12345          | Contractor label present but recordType is not 'Conversion'            |
| 67890          | employmentStatus in \['A','L'] but missing 'Active'/'OnLeave' label... |
| 54321          | Contractor label...; Hire date is in the future                        |

---

Let me know if youâ€™d like to make this configurable (e.g. whether to return single or multi-reason format).
