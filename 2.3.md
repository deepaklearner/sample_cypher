Got it! Here's the **full updated code** with clear, descriptive variable names replacing the previous generic masks, and using the DataFrame-only operations approach from before — including the `check_new_rejections` function with renamed variables:

```python
import pandas as pd
from datetime import datetime
from neo4j import GraphDatabase

# === Neo4j Configuration ===
uri = "bolt://localhost:7687"
username = "neo4j"
password = "your_password"  # replace with your actual Neo4j password

driver = GraphDatabase.driver(uri, auth=(username, password))

def fetch_user_labels(tx, emp_nums):
    query = """
    UNWIND $empNums AS empNum
    MATCH (u:User {employeeNumber: empNum})
    RETURN empNum AS employeeNumber, labels(u) AS labels
    """
    result = tx.run(query, empNums=emp_nums)
    return [record.data() for record in result]

def check_new_rejections(df):
    """
    Apply rejection rules and return mismatch_df with columns:
    - employeeNumber
    - Reason (combined if multiple)
    """
    # Mask: Rows where 'Contractor' label exists
    has_contractor_label = df['labels'].apply(lambda labels: 'Contractor' in labels)
    # Mask: Rows where recordType is NOT 'Conversion'
    is_wrong_record_type = df['recordType'] != 'Conversion'
    # Filter: Contractor label but wrong recordType
    contractor_wrong_record_type = df[has_contractor_label & is_wrong_record_type]
    contractor_df = contractor_wrong_record_type[['employeeNumber']].copy()
    contractor_df['Reason'] = "Contractor label present but recordType is not 'Conversion'"

    # Mask: employmentStatus is 'A' or 'L'
    is_employment_status_active_leave = df['employmentStatus'].isin(['A', 'L'])
    # Mask: Labels do NOT contain 'Active' or 'OnLeave'
    missing_active_onleave_label = ~df['labels'].apply(lambda labels: any(l in ['Active', 'OnLeave'] for l in labels))
    # Filter: employmentStatus mismatch with labels
    status_mismatch_df = df[is_employment_status_active_leave & missing_active_onleave_label]
    status_df = status_mismatch_df[['employeeNumber']].copy()
    status_df['Reason'] = "employmentStatus in ['A','L'] but missing 'Active'/'OnLeave' label in Neo4j"

    # Future hireDate check
    if 'hireDate' in df.columns:
        df['hireDate'] = pd.to_datetime(df['hireDate'], errors='coerce')
        today = pd.Timestamp.today().normalize()
        future_hire_mask = df['hireDate'] > today
        future_hires_df = df[future_hire_mask][['employeeNumber']].copy()
        future_hires_df['Reason'] = "Hire date is in the future"
    else:
        future_hires_df = pd.DataFrame(columns=['employeeNumber', 'Reason'])

    # Combine all mismatches into one DataFrame
    combined_mismatches = pd.concat([contractor_df, status_df, future_hires_df], ignore_index=True)

    # Group by employeeNumber and join multiple reasons with '; '
    mismatch_df = combined_mismatches.groupby('employeeNumber')['Reason'].agg('; '.join).reset_index()

    return mismatch_df


# === Main processing logic ===

# Assume df is your original DataFrame
# Step 1: Filter only employees
employee_df = df[df['userType'] == 'Employee'].copy()
employee_numbers = employee_df['employeeNumber'].tolist()

# Step 2: Fetch labels from Neo4j
with driver.session() as session:
    labels_data = session.read_transaction(fetch_user_labels, employee_numbers)

labels_df = pd.DataFrame(labels_data)

# Handle no Neo4j results
if labels_df.empty or 'employeeNumber' not in labels_df.columns:
    print("⚠️ No matching User nodes found in Neo4j.")
    mismatch_df = pd.DataFrame(columns=['employeeNumber', 'Reason'])
    
    # Check future hire dates from original df as well
    if 'hireDate' in df.columns:
        df['hireDate'] = pd.to_datetime(df['hireDate'], errors='coerce')
        today = pd.Timestamp.today().normalize()
        future_hires = df[df['hireDate'] > today]
        if not future_hires.empty:
            mismatch_df = future_hires[['employeeNumber']].copy()
            mismatch_df['Reason'] = "Hire date is in the future"
    
    valid_df = df[~df['employeeNumber'].isin(mismatch_df['employeeNumber'])]
    mismatch_df.to_csv("mismatch_log.csv", index=False)
    
    print("✅ Mismatch log saved (Neo4j returned no users)")
    print(f"✅ Valid records: {len(valid_df)}")
    print(f"❌ Mismatched records: {len(mismatch_df)}")
    exit()

# Step 3: Merge employee_df with labels_df on employeeNumber
merged_df = employee_df.merge(labels_df, on='employeeNumber', how='inner')

# Step 4: Check mismatches
mismatch_df = check_new_rejections(merged_df)

# Step 5: Filter valid records from original df
valid_df = df[~df['employeeNumber'].isin(mismatch_df['employeeNumber'])]

# Step 6: Save mismatch log
mismatch_df.to_csv("mismatch_log.csv", index=False)

print("✅ Mismatch log saved: mismatch_log.csv")
print(f"✅ Valid records count: {len(valid_df)}")
print(f"❌ Mismatched records count: {len(mismatch_df)}")
```

---

### Highlights:

* **Descriptive variable names** (`has_contractor_label`, `is_wrong_record_type`, etc.) for clarity.
* All mismatch rules combined cleanly inside `check_new_rejections`.
* Future `hireDate` check included.
* Graceful handling if Neo4j returns no user labels.
* Produces a CSV with only `employeeNumber` and combined `Reason` fields.

If you want me to help modularize this into separate files or wrap it into a class or script, just ask!
