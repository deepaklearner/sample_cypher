You can achieve this in SQL by performing a `JOIN` between `entitlement_master` and `eservice_data` on the `entitle_name` and `entitle_source = platform`, then pivoting the data based on the `rank` to create separate columns (`owner1`, `owner2`, `owner3`). Here's a sample SQL query for this transformation:

```sql
SELECT
    em.entitle_name,
    em.entitle_source,
    MAX(CASE WHEN ed.rank = 1 THEN ed.owner END) AS owner1,
    MAX(CASE WHEN ed.rank = 2 THEN ed.owner END) AS owner2,
    MAX(CASE WHEN ed.rank = 3 THEN ed.owner END) AS owner3
FROM
    entitlement_master em
LEFT JOIN
    eservice_data ed
    ON em.entitle_name = ed.entitle_name
   AND em.entitle_source = ed.platform
GROUP BY
    em.entitle_name,
    em.entitle_source;
```

### Explanation:

* `MAX(CASE WHEN ed.rank = X THEN ed.owner END)` is used to pivot rows into columns.
* `LEFT JOIN` ensures you still get a row from `entitlement_master` even if there is no matching `eservice_data`.
* `GROUP BY` groups the results by the composite key.

Would you like a version in a specific SQL dialect (e.g., PostgreSQL, MySQL, SQL Server)?
