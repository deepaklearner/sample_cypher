Got it — you want to **only process rows where `conversionType == "c2e"`**, and skip everything else.

We’ll handle this in **two places**:

1. **Early filter**: only send users with `conversionType == "c2e"` to Neo4j.
2. **Tag skipped users** with a reason if `conversionType != "c2e"`.

---

### ✅ Updated Logic Summary

We now have **three types** of skipped users:

* Not found in Neo4j
* Found, but failed validation
* `conversionType` not equal to `"c2e"`

---

### ✅ Final Updated Code

```python
import pandas as pd
from neo4j import GraphDatabase

# Neo4j connection
uri = "bolt://localhost:7687"
user = "neo4j"
password = "your_password"
driver = GraphDatabase.driver(uri, auth=(user, password))

# Sample DataFrame
# data_frame = pd.DataFrame({
#     'employeeNumber': ['123', '456', '789', '321'],
#     'conversionType': ['c2e', 'other', 'c2e', 'temp']
# })

# Step 1: Filter rows where conversionType == "c2e"
c2e_df = data_frame[data_frame['conversionType'].str.lower() == "c2e"].copy()
skipped_non_c2e_df = data_frame[data_frame['conversionType'].str.lower() != "c2e"].copy()
skipped_non_c2e_df['Reason'] = 'Conversion type is not c2e'

# Step 2: Create set of employee numbers
employee_numbers_set = set(c2e_df['employeeNumber'].unique())

# Step 3: Fetch only existing users from Neo4j
def fetch_existing_user_labels(emp_numbers):
    with driver.session() as session:
        query = """
        UNWIND $emp_numbers AS emp_number
        MATCH (u {employeeNumber: emp_number})
        RETURN emp_number AS employeeNumber, labels(u) AS labels
        """
        result = session.run(query, emp_numbers=list(emp_numbers))
        return pd.DataFrame([r.data() for r in result])

user_labels_df = fetch_existing_user_labels(employee_numbers_set)

# Step 4: Find users not found in Neo4j
found_employee_numbers = set(user_labels_df['employeeNumber'].unique())
not_found_employee_numbers = employee_numbers_set - found_employee_numbers

not_found_df = pd.DataFrame({
    'employeeNumber': list(not_found_employee_numbers),
    'Reason': 'User not found'
}).merge(c2e_df[['employeeNumber', 'conversionType']], on='employeeNumber', how='left')

# Step 5: Merge found users
merged_df = c2e_df.merge(user_labels_df, on='employeeNumber', how='inner')

# Step 6: Validate
def validate_row(row):
    labels = row['labels']
    if not any(label in labels for label in ["OnLeave", "Active"]):
        return "User node does not contain OnLeave or Active label"
    if "Employee" in labels:
        return "User is already an Employee"
    if "Domestic" not in labels:
        return "Domestic label not present"
    return None  # Valid

merged_df['Reason'] = merged_df.apply(validate_row, axis=1)

# Step 7: Split valid and skipped
skipped_validation_df = merged_df[merged_df['Reason'].notnull()][['employeeNumber', 'conversionType', 'Reason']]
valid_df = merged_df[merged_df['Reason'].isnull()].copy()

# Step 8: Combine all skipped
skipped_df = pd.concat([skipped_non_c2e_df, not_found_df, skipped_validation_df], ignore_index=True)

# Final Output
print("❌ Skipped users:")
print(skipped_df[['employeeNumber', 'conversionType', 'Reason']])

print("\n✅ Valid users:")
print(valid_df[['employeeNumber', 'conversionType']])
```

---

### ✅ Summary of Changes

* ✅ Early filtered rows with `conversionType != "c2e"` and tagged them with a reason.
* ✅ Only passed `"c2e"` users to Neo4j.
* ✅ Merged and validated only those.
* ✅ Clean output of skipped and valid users.

Let me know if you want this modularized into functions!
