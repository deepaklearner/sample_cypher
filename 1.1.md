Great idea! Using `UNWIND` to pass **all employeeNumbers at once** to Neo4j reduces round-trips and speeds things up.

---

### How to do it:

* Pass the full list of `employeeNumber`s as a parameter.
* Use `UNWIND` in Cypher to match users and return a mapping from `employeeNumber` → labels.
* Then, in Python, map back labels to each employeeNumber efficiently.

---

### Here's the updated approach with UNWIND:

```python
import pandas as pd
from neo4j import GraphDatabase

# Neo4j Config
uri = "bolt://localhost:7687"
username = "neo4j"
password = "your_password"  # replace with your password

driver = GraphDatabase.driver(uri, auth=(username, password))

employee_df = df[df['userType'] == 'Employee']

# Collect employeeNumbers list
emp_nums = employee_df['employeeNumber'].tolist()

# Cypher query to get labels for all employeeNumbers at once
def get_users_labels(tx, emp_nums):
    query = """
    UNWIND $empNums AS empNum
    MATCH (u:User {employeeNumber: empNum})
    RETURN empNum, labels(u) AS labels
    """
    result = tx.run(query, empNums=emp_nums)
    return {record["empNum"]: record["labels"] for record in result}

with driver.session() as session:
    empnum_to_labels = session.read_transaction(get_users_labels, emp_nums)

mismatched_records = []

for _, row in employee_df.iterrows():
    emp_num = row['employeeNumber']
    labels = empnum_to_labels.get(emp_num, [])

    if not labels:
        mismatched_records.append({
            "employeeNumber": emp_num,
            "Reason": "User node not found in Neo4j"
        })
        continue

    if 'Contractor' in labels and row['recordType'] != 'Conversion':
        mismatched_records.append({
            "employeeNumber": emp_num,
            "Reason": "Contractor label present but recordType is not 'Conversion'"
        })
        continue

    if row['employmentStatus'] in ['A', 'L']:
        if not any(l in labels for l in ['Active', 'OnLeave']):
            mismatched_records.append({
                "employeeNumber": emp_num,
                "Reason": f"employmentStatus '{row['employmentStatus']}' missing 'Active'/'OnLeave' label in Neo4j"
            })
            continue

mismatch_df = pd.DataFrame(mismatched_records)
valid_df = df[~df['employeeNumber'].isin(mismatch_df['employeeNumber'])]

mismatch_df.to_csv("mismatch_log.csv", index=False)

print("✅ Mismatch log created: mismatch_log.csv")
print(f"Valid records count: {len(valid_df)}")
print(f"Mismatch records count: {len(mismatch_df)}")
```

---

### What changed:

* The `get_users_labels` function passes the whole list `empNums` once.
* The Cypher query `UNWIND`s that list and returns labels per employeeNumber.
* We build a dictionary `empnum_to_labels` for quick lookup.
* The rest of the mismatch logic stays the same.

---

If you want help with batching large lists or anything else, just ask!
