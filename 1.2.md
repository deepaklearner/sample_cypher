To implement your validation pipeline, you'll need to interact with a Neo4j database using something like the `neo4j` Python driver (`neo4j-driver`), and apply the rules sequentially. Here‚Äôs a step-by-step script outline in Python that accomplishes this:

### üõ†Ô∏è Assumptions:

* `data_frame` is a pandas DataFrame with columns `employeeNumber` and `conversionType`.
* Neo4j is accessible with credentials.
* User nodes are indexed by `employeeNumber`.
* You're familiar with Python and Neo4j.

---

### ‚úÖ Python Code:

```python
import pandas as pd
from neo4j import GraphDatabase

# Neo4j connection setup
uri = "bolt://localhost:7687"
user = "neo4j"
password = "your_password"

driver = GraphDatabase.driver(uri, auth=(user, password))

# Output DataFrame for skipped rows
skipped_rows = []

def validate_user(tx, emp_number):
    result = tx.run(
        """
        MATCH (u {employeeNumber: $emp_number})
        RETURN labels(u) AS labels
        """,
        emp_number=emp_number
    )
    return result.single()

def process_dataframe(df):
    for _, row in df.iterrows():
        emp_number = row['employeeNumber']
        reason = None

        with driver.session() as session:
            user_record = session.read_transaction(validate_user, emp_number)

            if not user_record:
                reason = "User not found"
            else:
                labels = user_record['labels']
                if not any(label in labels for label in ["OnLeave", "Active"]):
                    reason = "User node do not contain OnLeave or Active label"
                elif "Employee" in labels:
                    reason = "User is already an Employee"
                elif "Domestic" not in labels:
                    reason = "Domestic label not present"

        if reason:
            skipped_rows.append({
                "employeeNumber": emp_number,
                "conversionType": row['conversionType'],
                "Reason": reason
            })

# Example DataFrame
# data_frame = pd.DataFrame({
#     'employeeNumber': ['123', '456', '789'],
#     'conversionType': ['TypeA', 'TypeB', 'TypeC']
# })

# Run validation
process_dataframe(data_frame)

# Final result
skipped_df = pd.DataFrame(skipped_rows)

# Save or display
print(skipped_df)
# skipped_df.to_csv("skipped_users.csv", index=False)
```

---

### üîç Notes:

* You can replace `MATCH (u {employeeNumber: $emp_number})` with a more specific label if necessary, e.g., `MATCH (u:User {employeeNumber: $emp_number})`.
* The script appends invalid users with a reason for skipping.
* Valid users (those not added to `skipped_rows`) can be processed further separately.

Would you like me to add handling for the valid users or extend this to multiple validation steps like logging or batch processing?
