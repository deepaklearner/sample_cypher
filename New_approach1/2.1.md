To compare entitlements between MySQL (source) and Neo4j (destination) and determine:

1. **New entitlements** — present in MySQL but not in Neo4j (based on `concat_attr_entitlements1`).
2. **Updated entitlements** — matching by `concat_attr_entitlements1` but differing `concat_attr_entitlements2`.

You can do this in Python using `pandas` for comparison. Here's a complete outline and example code.

---

### **Step-by-Step Plan**

1. **Fetch MySQL data** into a pandas DataFrame.
2. **Fetch Neo4j data** into a pandas DataFrame.
3. Compare `concat_attr_entitlements1` and `concat_attr_entitlements2`:

   * New: `concat_attr_entitlements1` in MySQL but not in Neo4j.
   * Updated: present in both, but `concat_attr_entitlements2` differs.

---

### **Python Code Example**

```python
import pandas as pd
from neo4j import GraphDatabase
import mysql.connector

# Step 1: Fetch MySQL data
def fetch_mysql_data():
    conn = mysql.connector.connect(
        host='your_host',
        user='your_user',
        password='your_password',
        database='edwmaster'
    )
    query = """
    SELECT
        entitle_name AS entitlementName,
        entitle_source AS targetSystem,
        entitle_desc AS description,
        risk_rating AS riskLevel,
        priv AS privilegedAccess,
        resource_type AS entitlementType,
        CONCAT(entitle_name, '|', entitle_source) AS concat_attr_entitlements1,
        CONCAT(
            entitle_name, '|',
            entitle_source, '|',
            COALESCE(entitle_desc, 'DNE'), '|',
            COALESCE(risk_rating, 'DNE'), '|',
            COALESCE(priv, 'DNE'), '|',
            COALESCE(resource_type, 'DNE')
        ) AS concat_attr_entitlements2
    FROM entitlement_master
    WHERE entitle_name LIKE 'APP_CTX%';
    """
    df_mysql = pd.read_sql(query, conn)
    conn.close()
    return df_mysql

# Step 2: Fetch Neo4j data
def fetch_neo4j_data():
    uri = "bolt://localhost:7687"
    driver = GraphDatabase.driver(uri, auth=("neo4j", "password"))

    cypher_query = """
    UNWIND $entitlements AS ent
    MATCH (e:Entitlement {
        entitlementName: ent.entitlementName,
        targetSystem: ent.targetSystem
    })
    OPTIONAL MATCH (e)-[:OWNER]->(u:User)
    RETURN
        e.entitlementName AS entitlementName,
        e.targetSystem AS targetSystem,
        e.description AS description,
        e.riskLevel AS riskLevel,
        e.priviledgedAccess AS priviledgedAccess,
        e.entitlementType AS entitlementType,
        e.entitlementName + '|' + e.targetSystem AS concat_attr_entitlements1,
        e.entitlementName + '|' + e.targetSystem + '|' +
            coalesce(e.description, 'DNE') + '|' +
            coalesce(e.riskLevel, 'DNE') + '|' +
            coalesce(e.priviledgedAccess, 'DNE') + '|' +
            coalesce(e.entitlementType, 'DNE') AS concat_attr_entitlements2
    """

    # Extract entitlementName and targetSystem from MySQL to pass as param
    df_mysql = fetch_mysql_data()
    entitlements = df_mysql[['entitlementName', 'targetSystem']].drop_duplicates().to_dict('records')

    with driver.session() as session:
        result = session.run(cypher_query, entitlements=entitlements)
        records = [record.data() for record in result]
    driver.close()

    return pd.DataFrame(records)

# Step 3: Compare MySQL vs Neo4j data
def compare_entitlements(df_mysql, df_neo4j):
    # New entitlements
    new_entitlements = df_mysql[
        ~df_mysql['concat_attr_entitlements1'].isin(df_neo4j['concat_attr_entitlements1'])
    ]

    # Join on concat_attr_entitlements1 to find updates
    merged = pd.merge(
        df_mysql,
        df_neo4j[['concat_attr_entitlements1', 'concat_attr_entitlements2']],
        on='concat_attr_entitlements1',
        how='inner',
        suffixes=('_mysql', '_neo4j')
    )
    updated_entitlements = merged[
        merged['concat_attr_entitlements2_mysql'] != merged['concat_attr_entitlements2_neo4j']
    ]

    return new_entitlements, updated_entitlements

# Run the comparison
df_mysql = fetch_mysql_data()
df_neo4j = fetch_neo4j_data()
new_ents, updated_ents = compare_entitlements(df_mysql, df_neo4j)

# Output
print("New entitlements:")
print(new_ents[['entitlementName', 'targetSystem']])

print("\nUpdated entitlements:")
print(updated_ents[['entitlementName', 'targetSystem']])
```

---

### Notes

* Replace credentials and connection details.
* You could extend this to sync changes back into Neo4j.
* You might want to normalize data types (e.g., `None` vs `'DNE'`) before comparing for robustness.

Would you like to integrate this into a reusable script or REST service next?
