Here is the **full Cypher query** rewritten using a safe structure to **avoid the unique constraint violation** on `Name.computedformattedName`. This version:

* Uses `OPTIONAL MATCH` to find an existing `Name` node
* Uses a conditional `CREATE` only if it doesn't exist
* Avoids conflicts with the uniqueness constraint
* Replaces the old relationship if the name has changed

---

### ✅ Full Cypher Query (Safe Against Unique Constraint Violations)

```cypher
UNWIND $rows AS row

// Step 1: Optional match existing HAS_ATTRIBUTE relationship to old Name node
OPTIONAL MATCH (usr:User {employeeNumber: row.CVSResourceid}) 
              -[r_has:HAS_ATTRIBUTE]-> (tgtNode:Name)

// Step 2: Update existing target node properties (if exists)
SET tgtNode.formattedName       = row.fullnameformatted,
    tgtNode.givenName           = row.givenName,
    tgtNode.middleName          = row.middleName,
    tgtNode.familyName          = row.familyName,
    tgtNode.honorificPrefix     = row.honorificPrefix,
    tgtNode.honorificSuffix     = row.honorificSuffix
REMOVE tgtNode.isTempProperty

// Step 3: Compare names; if different or node is null, mark for change
WITH row, usr, r_has, tgtNode,
     CASE 
         WHEN (row.concat_attr_Name <> tgtNode.computedformattedName OR tgtNode IS NULL) 
         THEN true 
         ELSE false 
     END AS codesDiffer
WHERE codesDiffer

// Step 4: Delete old relationship (but not node)
DELETE r_has

// Step 5: Mark user as updated
WITH row, usr
WHERE row.isName
SET usr.is_updated = 'Y'

// Step 6: Check if target Name node with desired computedformattedName already exists
OPTIONAL MATCH (existingName:Name { computedformattedName: row.concat_attr_Name })

// Step 7: Conditionally create or update the Name node
CALL {
  WITH row, existingName
  // Create if not exists
  WITH row WHERE existingName IS NULL
  CREATE (newName:Name {
    computedformattedName: row.concat_attr_Name,
    formattedName: row.fullnameformatted,
    givenName: row.givenName,
    middleName: row.middleName,
    familyName: row.familyName,
    honorificPrefix: row.honorificPrefix,
    honorificSuffix: row.honorificSuffix
  })
  RETURN newName AS Name_node
  UNION
  // Update if already exists
  WITH existingName, row
  SET existingName.formattedName   = row.fullnameformatted,
      existingName.givenName       = row.givenName,
      existingName.middleName      = row.middleName,
      existingName.familyName      = row.familyName,
      existingName.honorificPrefix = row.honorificPrefix,
      existingName.honorificSuffix = row.honorificSuffix
  RETURN existingName AS Name_node
}

// Step 8: Create relationship and clean up
MERGE (usr)-[:HAS_ATTRIBUTE]->(Name_node)
REMOVE Name_node.isTempProperty

RETURN COUNT(*) AS total
```

---

### ✅ Why this works

* **No duplicate node creation**: The conditional `CREATE` only runs if the node doesn't exist.
* **Safe updates**: If the node does exist, it's updated without re-creating or violating constraints.
* **Stable relationship management**: The old relationship is deleted if the name changes, and the new one is established.

Let me know if you're using APOC or need this query optimized for batch performance.
