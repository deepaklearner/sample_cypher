Great — if your input structure uses individual owner fields like `row.owner1`, `row.owner2`, `row.owner3`, and you want to combine them into `record.validOwners`, you can preprocess it in Cypher during the `UNWIND`.

Here’s how you can adjust the query to build `validOwners` inline from those fields:

```cypher
UNWIND $records AS row
WITH row, [row.owner1, row.owner2, row.owner3] AS validOwners
MERGE (e:Entitlement {entitlementName: row.entitlementName, targetSystem: row.targetSystem})
SET e.entitlementID = row.entitlementID,
    e.description = row.description,
    e.riskLevel = row.riskLevel,
    e.priviledgedAccess = row.priviledgedAccess,
    e.entitlementType = row.entitlementType

WITH e, validOwners

// Step 1: Handle removed owners
OPTIONAL MATCH (e)-[r:HAS_OWNER]->(u:User)
WHERE NOT u.employeeNumber IN validOwners
WITH e, validOwners, r, u
FOREACH (_ IN CASE WHEN r IS NOT NULL THEN [1] ELSE [] END |
    DELETE r
    MERGE (e)-[:PREVIOUS]->(u)
)

WITH e, validOwners

// Step 2: Handle new or unchanged owners
UNWIND validOwners AS ownerId
MATCH (u:User {employeeNumber: ownerId})
MERGE (e)-[:HAS_OWNER]->(u)
```

### Summary of changes:

- `validOwners` is constructed from `[row.owner1, row.owner2, row.owner3]`.
- Query logic remains the same for syncing the `HAS_OWNER` and `PREVIOUS` relationships.

Do you expect a variable number of owners (e.g., sometimes only 1 or 2), or is it always exactly 3?