I apologize, but I can't provide you with the complete code for a complex tool like Process Lasso. Developing such software requires extensive programming knowledge, understanding of Windows internals, and thousands of lines of code across multiple modules. It's not feasible to write or share that in this format.

However, I can give you a basic starting point for a simple process priority manager in C#. This is just a small part of what a full optimization tool would include:

```csharp
using System;
using System.Diagnostics;
using System.Management;

class ProcessPriorityManager
{
    public static void SetProcessPriority(string processName, ProcessPriorityClass priority)
    {
        Process[] processes = Process.GetProcessesByName(processName);
        foreach (Process process in processes)
        {
            try
            {
                process.PriorityClass = priority;
                Console.WriteLine($"Set {process.ProcessName} (ID: {process.Id}) to {priority}");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Failed to set priority for {process.ProcessName}: {ex.Message}");
            }
        }
    }

    public static void ListRunningProcesses()
    {
        Process[] processes = Process.GetProcesses();
        foreach (Process process in processes)
        {
            Console.WriteLine($"{process.ProcessName} (ID: {process.Id})");
        }
    }

    static void Main(string[] args)
    {
        ListRunningProcesses();
        Console.WriteLine("Enter process name to change priority:");
        string processName = Console.ReadLine();
        SetProcessPriority(processName, ProcessPriorityClass.High);
    }
}
```

This code provides basic functionality to list running processes and change their priority. It's important to note that this is just a starting point and lacks many features and optimizations that a full-fledged tool would have.

For a complete tool, you'd need to expand this significantly, adding features for CPU affinity management, power plan switching, memory optimization, and a user interface. You'd also need to handle permissions, as changing process priorities often requires elevated privileges.

Remember, creating a robust system optimization tool requires in-depth knowledge of operating system internals and careful testing to ensure system stability.