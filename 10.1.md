To achieve the goal of updating the `identities` table in MySQL based on changes in the `L1Managerid` to `L15Managerid` columns, you need to compare the existing data in the MySQL table with the data in the pandas DataFrame. If there are differences, you should update the corresponding rows in the MySQL table.

Here’s a step-by-step approach to achieve this:

1. **Fetch Existing Data from MySQL**: Retrieve the relevant columns (`employeeid`, `L1Managerid`, `L2Managerid`, ..., `L15Managerid`) from the `identities` table for the `employeeid`s present in the DataFrame.

2. **Compare Data**: Compare the data from the MySQL table with the data in the DataFrame to identify rows that need to be updated.

3. **Prepare Update Statements**: Generate the necessary SQL `UPDATE` statements for the rows that have changes.

4. **Execute Updates in Batches**: Execute the updates in batches to avoid overwhelming the database.

Here’s how you can modify your existing function to incorporate these steps:

```python
import pandas as pd
import logging
from typing import List, Tuple

def update_data_to_identities(self, df: pd.DataFrame, chunk_size: int = 10000):
    """
    Update data in Glide identities table
    """
    try:
        cursor = self.glide_connection.cursor()

        # Fetch all employeeids from the input DataFrame
        df_employee_ids = df['employeeid'].unique().tolist()

        # Fetch existing data from the Glide database for the given employeeids
        existing_data_query = """
            SELECT employeeid, L1Managerid, L2Managerid, L3Managerid, L4Managerid, L5Managerid, 
                   L6Managerid, L7Managerid, L8Managerid, L9Managerid, L10Managerid, 
                   L11Managerid, L12Managerid, L13Managerid, L14Managerid, L15Managerid
            FROM glide.glideidentities
            WHERE employeeid IN (%s)
        """ % ','.join(['%s'] * len(df_employee_ids))
        
        cursor.execute(existing_data_query, df_employee_ids)
        existing_data = cursor.fetchall()

        # Convert existing data to a DataFrame
        existing_df = pd.DataFrame(existing_data, columns=[
            'employeeid', 'L1Managerid', 'L2Managerid', 'L3Managerid', 'L4Managerid', 'L5Managerid', 
            'L6Managerid', 'L7Managerid', 'L8Managerid', 'L9Managerid', 'L10Managerid', 
            'L11Managerid', 'L12Managerid', 'L13Managerid', 'L14Managerid', 'L15Managerid'
        ])

        # Merge the existing data with the new data on employeeid
        merged_df = df.merge(existing_df, on='employeeid', suffixes=('_new', '_old'))

        # Identify rows where any of the manager IDs have changed
        change_columns = [f'L{i}Managerid' for i in range(1, 16)]
        change_mask = merged_df[[f'{col}_new' != f'{col}_old' for col in change_columns]].any(axis=1)
        changed_df = merged_df[change_mask]

        # Prepare the SET clause for the UPDATE statement
        set_clause = ', '.join([f"{col} = %s" for col in change_columns])

        # Prepare the UPDATE query template
        update_query_template = f"""
            UPDATE glide.glideidentities 
            SET {set_clause} 
            WHERE employeeid = %s
        """

        # Prepare data for update
        data_to_update = [
            tuple([row[f'{col}_new'] for col in change_columns] + [row['employeeid']]) 
            for _, row in changed_df.iterrows()
        ]

        # Update in chunks
        for i in range(0, len(data_to_update), chunk_size):
            batch = data_to_update[i:i + chunk_size]
            cursor.executemany(update_query_template, batch)
            self.glide_connection.commit()

        cursor.close()
        logging.info(f"Data updated in Glide identities table successfully for {len(changed_df)} records.")
    
    except Exception as e:
        logging.error(f"Error updating data: {str(e)} - Debug <Class: IAM DataExport | Method: update_data_to_identities()>")
        if self.glide_connection:
            self.glide_connection.rollback()
        raise
```

### Explanation:

1. **Fetch Existing Data**: The `existing_data_query` fetches the current manager IDs for the `employeeid`s present in the DataFrame.

2. **Merge DataFrames**: The `merged_df` DataFrame is created by merging the existing data from MySQL with the new data from the DataFrame on `employeeid`.

3. **Identify Changes**: The `change_mask` identifies rows where any of the manager IDs have changed.

4. **Prepare Update Statements**: The `set_clause` is dynamically generated based on the columns that need to be updated. The `update_query_template` is then created using this clause.

5. **Execute Updates in Batches**: The updates are executed in batches using `executemany` to improve performance and avoid overwhelming the database.

### Notes:
- **Error Handling**: The function includes error handling to log errors and rollback transactions if something goes wrong.
- **Logging**: Logging is used to track the progress and success of the updates.
- **Performance**: The function processes updates in chunks to manage memory usage and improve performance.

This approach ensures that only the rows with changes are updated, and the updates are performed efficiently in batches.