import os
import pandas as pd
import time
from datetime import datetime
import argparse
import logging
import tracemalloc
from src.db_operation.ne4j_operations import IAM_GraphOperations
from sc.utils.helper import read_creds, initialize_main_logger, get_config_stream
from neodi import GraphDatabase, exceptions

# Set up paths
currentdir = os.path.dirname(os.path.realpath(__file__))
parentdir = os.path.dirname(currentdir)
sys.path.append(parentdir)

# Entrypoint for Script to run
# cd pipeline_routines/supervisor_hierarchy & sh populate_supervisor_hierarchy.sh.

if __name__ == "__main__":
    tracemalloc.start()

    parser = argparse.ArgumentParser(description="Populate supervisor hierarchy")
    parser.add_argument(
        "--load_type", "-L", type=str, help="Specify the load_type: full/delta"
    )
    parser.add_argument("--log_location", type=str, help="Specify the log location")
    args = parser.parse_args()

    # Initializing variables
    load_type = args.load_type.lower()
    configuration_file = "/config/config.yaml"

    # Reading Configuration file and getting data for passed configs
    logger = initialize_main_logger()
    baseconfigstream = get_config_stream(configuration_file)
    database_configs = read_creds(configuration_file)

    batch_size = baseconfigstream["supervisor_hierarchy_ProjConfig"]["batch_size"]
    time_window_in_minutes = baseconfigstream[
        "supervisor_hierarchy_ProjConfig"
    ]["time_window_in_minutes"]

    iam_graph_operations = IAM_GraphOperations(database_configs)
    flag = False

    def run_query(query):
        with iam_graph_operations.driver.session() as session:
            result = session.run(query)
            return pd.DataFrame(
                [record.values() for record in result], columns=result.keys()
            )

    try:
        # Step 1 - Match users with incorrect "REPORTS_TO" relation
        match_user_qry_full = """
        MATCH (n:User)-[r:REPORTS_TO]->(m:User)
        WHERE n.managerid IS NOT NULL AND n.managerid <> m.employeeNumber
        RETURN n.employeeNumber AS Employee, n.managerid AS CurrentManager, m.employeeNumber AS RelatedManager
        """

        match_user_qry_delta = f"""
        MATCH (n:User)-[r]-(:ApplicationAccount)
        WHERE datetime(r.lastModifiedOn) > datetime() - duration({{minutes: {time_window_in_minutes}}})
        MATCH (n)-[r:REPORTS_TO]->(m:User)
        WHERE n.managerid IS NOT NULL AND n.managerid <> m.employeeNumber
        RETURN n.employeeNumber AS Employee, n.managerid AS CurrentManager, m.employeeNumber AS RelatedManager
        """

        if load_type == "delta":
            user_df = run_query(match_user_qry_delta)
        elif load_type == "full":
            user_df = run_query(match_user_qry_full)
        else:
            raise ValueError(f"Unknown argument passed: {load_type}")

        # Step 2 - Delete incorrect "REPORTS_TO" relations
        if not user_df.empty:
            delete_qry = """
            UNWIND $rows AS row
            MATCH (n:User {employeeNumber: row.Employee})-[r:REPORTS_TO]->(m:User {employeeNumber: row.RelatedManager})
            DELETE r
            RETURN count(*) AS total
            """
            result1 = iam_graph_operations.insert_data(
                delete_qry, user_df, batch_size=batch_size, feature_name="populate_supervisor"
            )

        # Step 3 - Match users without "REPORTS_TO" relationships
        match_user_without_mngr_full = """
        MATCH (n:User)
        WHERE n.managerid IS NOT NULL AND 
              ('Employee' IN labels(n) OR 'Contractor' IN labels(n) OR 'Vendor' IN labels(n)) 
              AND NOT EXISTS((n)-[:REPORTS_TO]->(:User))
        RETURN n.employeeNumber AS Employee, n.managerid AS CurrentManager
        """

        match_user_without_mngr_delta = f"""
        MATCH (n:User)-[r]-(:ApplicationAccount)
        WHERE datetime(r.lastModifiedOn) > datetime() - duration({{minutes: {time_window_in_minutes}}})
        MATCH (n)
        WHERE n.managerid IS NOT NULL AND 
              ('Employee' IN labels(n) OR 'Contractor' IN labels(n) OR 'Vendor' IN labels(n)) 
              AND NOT EXISTS((n)-[:REPORTS_TO]->(:User))
        RETURN n.employeeNumber AS Employee, n.managerid AS CurrentManager
        """

        if load_type == "delta":
            unrelated_user_df = run_query(match_user_without_mngr_delta)
        elif load_type == "full":
            unrelated_user_df = run_query(match_user_without_mngr_full)
        else:
            raise ValueError(f"Unknown argument passed: {load_type}")

        # Step 4 - Create new "REPORTS_TO" relationships
        if not unrelated_user_df.empty:
            create_relation_qry = """
            UNWIND $rows AS row
            MATCH (n:User {employeeNumber: row.Employee})
            OPTIONAL MATCH (m:User {employeeNumber: row.CurrentManager})
            WHERE m IS NOT NULL
            MERGE (n)-[:REPORTS_TO]->(m)
            RETURN count(*) AS total
            """
            result2 = iam_graph_operations.insert_data(
                create_relation_qry, unrelated_user_df, batch_size=batch_size, feature_name="populate_supervisor"
            )

    except exceptions.Neo4jError as e:
        flag = True
        logging.error(f"Error executing Cypher query: {e}")

    if flag:
        logging.error(f"Supervisor hierarchy {load_type} job unsuccessful, please debug logs")
    else:
        logging.info(f"Supervisor hierarchy {load_type} job ran successfully with batch_size {batch_size}")

    tracemalloc.stop()
