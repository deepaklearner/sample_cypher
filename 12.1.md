def update_data_to_identities(self, df: pd.DataFrame, chunk_size: int = 10000):
    """
    Update data in Glide identities table.
    """
    try:
        cursor = self.glide_connection.cursor()

        # Fetch all resourceids from the input DataFrame by mapping EmployeeID to resourceid
        df_resource_ids = df['EmployeeID'].unique().tolist()

        # Fetch existing data from the Glide database for the given resourceids
        glide_data_query = """
            SELECT resourceid, L1ManagerID, L2ManagerID, L3ManagerID, L4ManagerID, L5ManagerID, 
                   L6ManagerID, L7ManagerID, L8ManagerID, L9ManagerID, L10ManagerID, 
                   L11ManagerID, L12ManagerID, L13ManagerID, L14ManagerID, L15ManagerID
            FROM glide.glideidentities
            WHERE resourceid IN (%s)
        """ % ','.join(['%s'] * len(df_resource_ids))
        
        cursor.execute(glide_data_query, df_resource_ids)
        glide_data = cursor.fetchall()

        # Convert existing data to a DataFrame
        glide_df = pd.DataFrame(glide_data, columns=[
            'resourceid', 'L1ManagerID', 'L2ManagerID', 'L3ManagerID', 'L4ManagerID', 'L5ManagerID', 
            'L6ManagerID', 'L7ManagerID', 'L8ManagerID', 'L9ManagerID', 'L10ManagerID', 
            'L11ManagerID', 'L12ManagerID', 'L13ManagerID', 'L14ManagerID', 'L15ManagerID'
        ])

        # Merge the existing data with the new data on resourceid (EmployeeID will map to resourceid)
        merged_df = df.merge(glide_df, left_on='EmployeeID', right_on='resourceid', suffixes=('_new', '_old'))

        # Identify columns for manager IDs
        manager_columns = [f'L{i}ManagerID' for i in range(1, 16)]
        
        # Create a mask that checks if any of the manager IDs have changed
        change_mask = merged_df.apply(
            lambda row: any(row[f'{col}_new'] != row[f'{col}_old'] for col in manager_columns), axis=1
        )
        
        # Filter the rows where there are changes
        changed_df = merged_df[change_mask]

        # Log missing resourceids (EmployeeID) in the Glide database
        missing_resource_ids = set(df['EmployeeID']) - set(glide_df['resourceid'])
        if missing_resource_ids:
            logging.info(f"Missing resourceid values in glide.glideidentities: {missing_resource_ids}")

        # If there are no changes, skip the update
        if changed_df.empty:
            logging.info("No changes detected. Skipping update.")
            return

        # Prepare the columns to be updated (including all the manager columns and other required columns)
        req_columns = df.columns.tolist()  # Assuming all columns in df are required for update
        set_clause = ', '.join([f"{col} = %s" for col in req_columns])

        # Prepare the UPDATE query template
        update_query_template = f"""
            UPDATE glide.glideidentities 
            SET {set_clause} 
            WHERE resourceid = %s
        """

        # Prepare data for update (for each row that has changed)
        data_to_update = [
            tuple([row[f'{col}_new'] for col in req_columns] + [row['resourceid']]) 
            for _, row in changed_df.iterrows()
        ]

        # Update in chunks
        for i in range(0, len(data_to_update), chunk_size):
            batch = data_to_update[i:i + chunk_size]
            cursor.executemany(update_query_template, batch)
            self.glide_connection.commit()

        cursor.close()
        logging.info(f"Data updated in Glide identities table successfully for {len(changed_df)} records.")
    
    except Exception as e:
        logging.error(f"Error updating data: {str(e)} - Debug <Class: IAM DataExport | Method: update_data_to_identities()>")
        if self.glide_connection:
            self.glide_connection.rollback()
        raise
