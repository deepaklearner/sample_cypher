Thanks for the clarification!

You're saying:

> As soon as a user **fails one validation**, skip further checks and record the reason. Don't continue with the next validation rules.

This is a **short-circuit validation** — once a failure is found, we stop. We'll still use DataFrame operations with a custom function applied row-wise (`apply(axis=1)`), but with short-circuit logic inside.

---

### ✅ Updated Code with Short-Circuit Rule Logic

```python
import pandas as pd
from neo4j import GraphDatabase

# Neo4j connection
uri = "bolt://localhost:7687"
user = "neo4j"
password = "your_password"
driver = GraphDatabase.driver(uri, auth=(user, password))

# Sample input DataFrame
# data_frame = pd.DataFrame({
#     'employeeNumber': ['123', '456', '789'],
#     'conversionType': ['TypeA', 'TypeB', 'TypeC']
# })

# Step 1: Batch fetch from Neo4j
def fetch_user_labels(employee_numbers):
    with driver.session() as session:
        query = """
        UNWIND $emp_numbers AS emp_number
        OPTIONAL MATCH (u {employeeNumber: emp_number})
        RETURN emp_number AS employeeNumber, labels(u) AS labels
        """
        result = session.run(query, emp_numbers=employee_numbers)
        return pd.DataFrame([r.data() for r in result])

employee_numbers = data_frame['employeeNumber'].unique().tolist()
user_labels_df = fetch_user_labels(employee_numbers)

# Step 2: Merge results into original DataFrame
merged_df = data_frame.merge(user_labels_df, on='employeeNumber', how='left')

# Step 3: Short-circuit validation logic
def validate_row(row):
    labels = row['labels']
    
    if pd.isna(labels):
        return "User not found"
    
    if not any(label in labels for label in ["OnLeave", "Active"]):
        return "User node do not contain OnLeave or Active label"
    
    if "Employee" in labels:
        return "User is already an Employee"
    
    if "Domestic" not in labels:
        return "Domestic label not present"
    
    return None  # All validations passed

# Apply validations
merged_df['Reason'] = merged_df.apply(validate_row, axis=1)

# Step 4: Split results
skipped_df = merged_df[merged_df['Reason'].notnull()].copy()
valid_df = merged_df[merged_df['Reason'].isnull()].copy()

# Output
print("❌ Skipped users:")
print(skipped_df[['employeeNumber', 'conversionType', 'Reason']])

print("\n✅ Valid users:")
print(valid_df[['employeeNumber', 'conversionType']])
```

---

### ✅ Key Behavior:

* If a user is not found → Stop and record `"User not found"`
* If found, but missing `"OnLeave"` or `"Active"` → Stop and record reason
* If passes above, but has `"Employee"` → Stop and record reason
* If passes all above, but lacks `"Domestic"` → Stop and record reason
* Only those passing **all rules** end up in `valid_df`.

---

Would you like me to return the valid users with extracted flags as well (like `isOnLeave`, `isDomestic`)?
