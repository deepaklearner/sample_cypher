Ah â€” thank you for clarifying! You're specifically asking:

> **Can we do the pivot (to get `owner1`, `owner2`, `owner3`) in the SQL used to populate `ed_df`, so that `em_batch.merge(...)` gives a single row per entitle?**

### âœ… Yes â€” You Can Pivot Directly in the `ed_df` Query!

If you rewrite the `eservice_data` query to return one row per `(entitle_name, platform)` with columns `owner1`, `owner2`, `owner3`, then your merge will behave exactly as expected â€” one row per entitle, with all `ownerX` columns already in place.

---

### ðŸ›  Modify the SQL Query for `ed_df`:

Hereâ€™s the SQL that does the pivot in the query itself using `CASE WHEN` and `MAX()`:

```sql
SELECT
    entitle_name,
    platform AS entitle_source,
    MAX(CASE WHEN rank = 1 THEN owner END) AS owner1,
    MAX(CASE WHEN rank = 2 THEN owner END) AS owner2,
    MAX(CASE WHEN rank = 3 THEN owner END) AS owner3
FROM eservice_data
WHERE (entitle_name, platform) IN %s
GROUP BY entitle_name, platform;
```

This returns:

* One row per entitle
* Columns: `entitle_name`, `entitle_source`, `owner1`, `owner2`, `owner3`

---

### âœ… Now Your Merge Works As Expected:

```python
# Merge works like a left join from entitlement_master
merged = em_batch.merge(ed_df, on=['entitle_name', 'entitle_source'], how='left')
```

You no longer need to pivot in pandas â€” it's already done in SQL.

---

### ðŸ§  Why This Is Efficient:

* Reduces the volume of data transferred from DB â†’ Python.
* Eliminates post-processing steps in pandas.
* Keeps the batch logic clean and scalable.

---

Let me know if you'd like this version wrapped into your full batch script â€” or extended to support more rank levels.
