To **filter out the mismatched records from the original `df`**, you need to:

1. Identify the mismatched `employeeNumber`s.
2. Use that to filter out those rows from the original `df`.

Here‚Äôs how you can modify the previous code to get two DataFrames:

* `valid_df`: all records that passed the checks.
* `mismatch_df`: all records that failed the checks.

### ‚úÖ Updated Script:

```python
import pandas as pd
from neo4j import GraphDatabase

# Neo4j connection
uri = "bolt://localhost:7687"
username = "neo4j"
password = "your_password"
driver = GraphDatabase.driver(uri, auth=(username, password))

# Step 1: Filter where userType == 'Employee'
employee_df = df[df['userType'] == 'Employee']

# For mismatches
mismatched_emp_nums = []

def check_user(tx, emp_num):
    query = """
    MATCH (u:User {employeeNumber: $emp_num})
    RETURN labels(u) AS labels
    """
    result = tx.run(query, emp_num=emp_num)
    record = result.single()
    return record["labels"] if record else []

# Status mapping
status_map = {'A': 'Active', 'L': 'OnLeave'}

with driver.session() as session:
    for _, row in employee_df.iterrows():
        emp_num = row['employeeNumber']
        labels = session.read_transaction(check_user, emp_num)

        # User not found
        if not labels:
            mismatched_emp_nums.append(emp_num)
            continue

        # Contractor check
        if 'Contractor' in labels and row['recordType'] != 'Conversion':
            mismatched_emp_nums.append(emp_num)
            continue

        # Employment status label check
        expected_label = status_map.get(row['employmentStatus'])
        if expected_label and expected_label not in labels:
            mismatched_emp_nums.append(emp_num)
            continue

# Filter mismatches and valid rows
mismatch_df = df[df['employeeNumber'].isin(mismatched_emp_nums)]
valid_df = df[~df['employeeNumber'].isin(mismatched_emp_nums)]

# Save mismatches to log
mismatch_df.to_csv('mismatch_log.csv', index=False)

print("‚úÖ Done. Mismatches written to 'mismatch_log.csv'.")
```

### üîç Result:

* `mismatch_df` contains all invalid rows.
* `valid_df` contains only rows that passed all checks.
* Both are filtered from the original `df`.

Let me know if you'd like to log the reason for each mismatch or optimize performance for large datasets.
