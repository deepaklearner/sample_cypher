To make the number of `ManagerID` columns configurable and avoid hardcoding the range from `L1Managerid` to `L15Managerid`, we can parametrize this value and build the column names dynamically.

You can add an argument to the function (e.g., `num_managers`) to specify how many `ManagerID` columns you want to include. The column names can then be generated dynamically based on this parameter.

### Updated Code with Dynamic Manager Columns:

```python
def update_data_to_identities(self, df: pd.DataFrame, num_managers: int = 15, chunk_size: int = 10000):
    """
    Update data in Glide identities table.
    """
    try:
        cursor = self.glide_connection.cursor()

        # Rename 'EmployeeID' to 'resourceid' to match Glide column name
        df = df.rename(columns={'EmployeeID': 'resourceid'})

        # Fetch all resourceids from the input DataFrame (now 'resourceid')
        df_resource_ids = df['resourceid'].unique().tolist()

        # Fetch existing data from the Glide database for the given resourceids
        glide_data_query = """
            SELECT resourceid, {}
            FROM glide.glideidentities
            WHERE resourceid IN (%s)
        """.format(', '.join([f'L{i}Managerid' for i in range(1, num_managers + 1)]))  # Dynamically generating manager columns
        
        cursor.execute(glide_data_query, df_resource_ids)
        glide_data = cursor.fetchall()

        # Convert existing data to a DataFrame
        glide_columns = ['resourceid'] + [f'L{i}Managerid' for i in range(1, num_managers + 1)]  # Dynamic columns
        glide_df = pd.DataFrame(glide_data, columns=glide_columns)

        # Merge the existing data with the new data on resourceid (EmployeeID will map to resourceid)
        merged_df = df.merge(glide_df, left_on='resourceid', right_on='resourceid', suffixes=('_new', '_old'))

        # Identify manager-related columns
        manager_columns = [f'L{i}Managerid' for i in range(1, num_managers + 1)]  # Dynamic manager columns

        # Create a mask that checks if any of the manager IDs have changed
        change_mask = merged_df.apply(
            lambda row: any(row[f'{col}_new'] != row[f'{col}_old'] for col in manager_columns), axis=1
        )

        # Filter the rows where there are changes
        changed_df = merged_df[change_mask]

        # Log missing resourceids (EmployeeID) in the Glide database
        missing_resource_ids = set(df['resourceid']) - set(glide_df['resourceid'])
        if missing_resource_ids:
            logging.info(f"Missing resourceid values in glide.glideidentities: {missing_resource_ids}")

        # If there are no changes, skip the update
        if changed_df.empty:
            logging.info("No changes detected. Skipping update.")
            return

        # Drop columns with '_old' suffix for manager-related columns only
        changed_df = changed_df.drop([f'{col}_old' for col in manager_columns if f'{col}_old' in changed_df.columns], axis=1)

        # Rename columns with '_new' suffix to the original column names for manager-related columns
        changed_df = changed_df.rename(columns={f'{col}_new': col for col in manager_columns if f'{col}_new' in changed_df.columns})

        # Prepare the columns to be updated (including all the manager columns and other required columns)
        req_columns = changed_df.columns.tolist()  # Now 'resourceid' is included as well
        set_clause = ', '.join([f"{col} = %s" for col in req_columns])

        # Prepare the UPDATE query template
        update_query_template = f"""
            UPDATE glide.glideidentities 
            SET {set_clause} 
            WHERE resourceid = %s
        """

        # Prepare data for update (for each row that has changed)
        data_to_update = [
            tuple([row[col] for col in req_columns] + [row['resourceid']]) 
            for _, row in changed_df.iterrows()
        ]

        # Update in chunks
        for i in range(0, len(data_to_update), chunk_size):
            batch = data_to_update[i:i + chunk_size]
            cursor.executemany(update_query_template, batch)
            self.glide_connection.commit()

        cursor.close()
        logging.info(f"Data updated in Glide identities table successfully for {len(changed_df)} records.")
    
    except Exception as e:
        logging.error(f"Error updating data: {str(e)} - Debug <Class: IAM DataExport | Method: update_data_to_identities()>")
        if self.glide_connection:
            self.glide_connection.rollback()
        raise
```

### Key Changes:
1. **`num_managers` Parameter**: 
   - Added the `num_managers` argument to specify how many manager columns (from `L1Managerid` to `L{num_managers}Managerid`) to handle dynamically.
   
2. **Dynamic Column Generation**:
   - For the SQL query (`glide_data_query`), the list of manager columns is dynamically generated based on `num_managers`.
   - Similarly, the columns in the `glide_df` DataFrame and the manager columns list are generated dynamically.

3. **Dynamically Handle Manager Columns**: 
   - All the logic related to identifying changed rows (`change_mask`), dropping `_old` columns, and renaming `_new` columns is applied to the dynamically generated list of manager columns.

### How It Works:
- The `num_managers` argument allows you to control how many `ManagerID` columns should be handled. If you want 20 manager levels instead of 15, you can simply pass `num_managers=20` when calling the function.
  
For example:
```python
# Calling with 20 ManagerID columns
update_data_to_identities(df, num_managers=20)
```

This should give you the flexibility to easily adjust the number of manager levels without needing to modify the code for each case. Let me know if you need further adjustments!