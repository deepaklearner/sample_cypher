Sure! To avoid any potential risk to other columns that may have `_old` or `_new` suffixes, we can specifically handle only the manager-related columns (`L1Managerid` to `L15Managerid`).

Hereâ€™s how we can do that:

1. **Drop Columns with `_old` Suffix for Manager Columns**: Only drop columns that end with `_old` for the manager columns.
2. **Rename Columns with `_new` Suffix for Manager Columns**: Only rename columns that end with `_new` for the manager columns.

### Updated Code:

```python
def update_data_to_identities(self, df: pd.DataFrame, chunk_size: int = 10000):
    """
    Update data in Glide identities table.
    """
    try:
        cursor = self.glide_connection.cursor()

        # Rename 'EmployeeID' to 'resourceid' to match Glide column name
        df = df.rename(columns={'EmployeeID': 'resourceid'})

        # Fetch all resourceids from the input DataFrame (now 'resourceid')
        df_resource_ids = df['resourceid'].unique().tolist()

        # Fetch existing data from the Glide database for the given resourceids
        glide_data_query = """
            SELECT resourceid, L1Managerid, L2Managerid, L3Managerid, L4Managerid, L5Managerid, 
                   L6Managerid, L7Managerid, L8Managerid, L9Managerid, L10Managerid, 
                   L11Managerid, L12Managerid, L13Managerid, L14Managerid, L15Managerid
            FROM glide.glideidentities
            WHERE resourceid IN (%s)
        """ % ','.join(['%s'] * len(df_resource_ids))
        
        cursor.execute(glide_data_query, df_resource_ids)
        glide_data = cursor.fetchall()

        # Convert existing data to a DataFrame
        glide_df = pd.DataFrame(glide_data, columns=[
            'resourceid', 'L1Managerid', 'L2Managerid', 'L3Managerid', 'L4Managerid', 'L5Managerid', 
            'L6Managerid', 'L7Managerid', 'L8Managerid', 'L9Managerid', 'L10Managerid', 
            'L11Managerid', 'L12Managerid', 'L13Managerid', 'L14Managerid', 'L15Managerid'
        ])

        # Merge the existing data with the new data on resourceid (EmployeeID will map to resourceid)
        merged_df = df.merge(glide_df, left_on='resourceid', right_on='resourceid', suffixes=('_new', '_old'))

        # Identify manager-related columns
        manager_columns = [f'L{i}Managerid' for i in range(1, 16)]

        # Create a mask that checks if any of the manager IDs have changed
        change_mask = merged_df.apply(
            lambda row: any(row[f'{col}_new'] != row[f'{col}_old'] for col in manager_columns), axis=1
        )

        # Filter the rows where there are changes
        changed_df = merged_df[change_mask]

        # Log missing resourceids (EmployeeID) in the Glide database
        missing_resource_ids = set(df['resourceid']) - set(glide_df['resourceid'])
        if missing_resource_ids:
            logging.info(f"Missing resourceid values in glide.glideidentities: {missing_resource_ids}")

        # If there are no changes, skip the update
        if changed_df.empty:
            logging.info("No changes detected. Skipping update.")
            return

        # Drop columns with '_old' suffix for manager-related columns only
        changed_df = changed_df.drop([f'{col}_old' for col in manager_columns if f'{col}_old' in changed_df.columns], axis=1)

        # Rename columns with '_new' suffix to the original column names for manager-related columns
        changed_df = changed_df.rename(columns={f'{col}_new': col for col in manager_columns if f'{col}_new' in changed_df.columns})

        # Prepare the columns to be updated (including all the manager columns and other required columns)
        req_columns = changed_df.columns.tolist()  # Now 'resourceid' is included as well
        set_clause = ', '.join([f"{col} = %s" for col in req_columns])

        # Prepare the UPDATE query template
        update_query_template = f"""
            UPDATE glide.glideidentities 
            SET {set_clause} 
            WHERE resourceid = %s
        """

        # Prepare data for update (for each row that has changed)
        data_to_update = [
            tuple([row[col] for col in req_columns] + [row['resourceid']]) 
            for _, row in changed_df.iterrows()
        ]

        # Update in chunks
        for i in range(0, len(data_to_update), chunk_size):
            batch = data_to_update[i:i + chunk_size]
            cursor.executemany(update_query_template, batch)
            self.glide_connection.commit()

        cursor.close()
        logging.info(f"Data updated in Glide identities table successfully for {len(changed_df)} records.")
    
    except Exception as e:
        logging.error(f"Error updating data: {str(e)} - Debug <Class: IAM DataExport | Method: update_data_to_identities()>")
        if self.glide_connection:
            self.glide_connection.rollback()
        raise
```

### Key Changes:
1. **Drop `_old` Columns**: The columns with the `_old` suffix are removed, but only for the manager-related columns (`L1Managerid` to `L15Managerid`).
   - We specifically drop the columns with the `_old` suffix by checking for each manager column and ensuring that the `_old` version exists.

2. **Rename `_new` Columns**: For the manager-related columns, the columns with the `_new` suffix are renamed back to their original names (without the `_new` suffix).
   - We use the `rename()` method to rename the manager columns that have the `_new` suffix.

### Summary:
- Only the manager columns (L1Managerid to L15Managerid) are affected by the `_old` and `_new` suffixes. Other columns in the DataFrame are left untouched.
- The code now only processes the manager columns when checking for changes, renaming, and removing suffixes.
  
Let me know if this works as expected or if you run into any other issues!