Yes, you can move `match_user_qry` and `match_user_without_mngr_qry` to helper functions as well. This will further improve modularity and make the code more maintainable. You can create a helper function that returns the appropriate query based on the `load_type` for both cases. Hereâ€™s how you could structure it:

### Refactored Code with Helper Functions for Queries:

```python
import os
import sys
import pandas as pd
import logging
import tracemalloc
import argparse
from datetime import datetime
from src.db_operation.ne4j_operations import IAM_GraphOperations
from sc.utils.helper import read_creds, initialize_main_logger, get_config_stream
from neodi import GraphDatabase, exceptions

# Set up paths
currentdir = os.path.dirname(os.path.realpath(__file__))
parentdir = os.path.dirname(currentdir)
sys.path.append(parentdir)

def initialize_configurations(configuration_file="/config/config.yaml"):
    """Load and return configuration and database credentials."""
    logger = initialize_main_logger()
    baseconfigstream = get_config_stream(configuration_file)
    database_configs = read_creds(configuration_file)
    batch_size = baseconfigstream["supervisor_hierarchy_ProjConfig"]["batch_size"]
    time_window_in_minutes = baseconfigstream["supervisor_hierarchy_ProjConfig"]["time_window_in_minutes"]
    return baseconfigstream, database_configs, batch_size, time_window_in_minutes

def run_query(iam_graph_operations, query):
    """Run a query and return results as a DataFrame."""
    with iam_graph_operations.driver.session() as session:
        result = session.run(query)
        return pd.DataFrame([record.values() for record in result], columns=result.keys())

def delete_incorrect_reports(iam_graph_operations, user_df, batch_size):
    """Delete incorrect 'REPORTS_TO' relations."""
    delete_qry = """
    UNWIND $rows AS row
    MATCH (n:User {employeeNumber: row.Employee})-[r:REPORTS_TO]->(m:User {employeeNumber: row.RelatedManager})
    DELETE r
    RETURN count(*) AS total
    """
    return iam_graph_operations.insert_data(delete_qry, user_df, batch_size=batch_size, feature_name="populate_supervisor")

def create_reports(iam_graph_operations, unrelated_user_df, batch_size):
    """Create new 'REPORTS_TO' relations."""
    create_relation_qry = """
    UNWIND $rows AS row
    MATCH (n:User {employeeNumber: row.Employee})
    OPTIONAL MATCH (m:User {employeeNumber: row.CurrentManager})
    WHERE m IS NOT NULL
    MERGE (n)-[:REPORTS_TO]->(m)
    RETURN count(*) AS total
    """
    return iam_graph_operations.insert_data(create_relation_qry, unrelated_user_df, batch_size=batch_size, feature_name="populate_supervisor")

def get_match_user_query(load_type, time_window_in_minutes):
    """Return the appropriate 'match_user' query based on load_type."""
    match_user_qry = {
        "full": """
            MATCH (n:User)-[r:REPORTS_TO]->(m:User)
            WHERE n.managerid IS NOT NULL AND n.managerid <> m.employeeNumber
            RETURN n.employeeNumber AS Employee, n.managerid AS CurrentManager, m.employeeNumber AS RelatedManager
        """,
        "delta": f"""
            MATCH (n:User)-[r]-(:ApplicationAccount)
            WHERE datetime(r.lastModifiedOn) > datetime() - duration({{minutes: {time_window_in_minutes}}})
            MATCH (n)-[r:REPORTS_TO]->(m:User)
            WHERE n.managerid IS NOT NULL AND n.managerid <> m.employeeNumber
            RETURN n.employeeNumber AS Employee, n.managerid AS CurrentManager, m.employeeNumber AS RelatedManager
        """
    }
    return match_user_qry.get(load_type)

def get_match_user_without_manager_query(load_type, time_window_in_minutes):
    """Return the appropriate 'match_user_without_mngr' query based on load_type."""
    match_user_without_mngr_qry = {
        "full": """
            MATCH (n:User)
            WHERE n.managerid IS NOT NULL AND 
                  ('Employee' IN labels(n) OR 'Contractor' IN labels(n) OR 'Vendor' IN labels(n)) 
                  AND NOT EXISTS((n)-[:REPORTS_TO]->(:User))
            RETURN n.employeeNumber AS Employee, n.managerid AS CurrentManager
        """,
        "delta": f"""
            MATCH (n:User)-[r]-(:ApplicationAccount)
            WHERE datetime(r.lastModifiedOn) > datetime() - duration({{minutes: {time_window_in_minutes}}})
            MATCH (n)
            WHERE n.managerid IS NOT NULL AND 
                  ('Employee' IN labels(n) OR 'Contractor' IN labels(n) OR 'Vendor' IN labels(n)) 
                  AND NOT EXISTS((n)-[:REPORTS_TO]->(:User))
            RETURN n.employeeNumber AS Employee, n.managerid AS CurrentManager
        """
    }
    return match_user_without_mngr_qry.get(load_type)

def main():
    tracemalloc.start()

    # Argument parsing
    parser = argparse.ArgumentParser(description="Populate supervisor hierarchy")
    parser.add_argument("--load_type", "-L", type=str, help="Specify the load_type: full/delta")
    parser.add_argument("--log_location", type=str, help="Specify the log location")
    args = parser.parse_args()

    # Initialize configurations
    load_type = args.load_type.lower()
    configuration_file = "/config/config.yaml"
    baseconfigstream, database_configs, batch_size, time_window_in_minutes = initialize_configurations(configuration_file)

    iam_graph_operations = IAM_GraphOperations(database_configs)
    is_error_occurred = False

    try:
        # Step 1 - Query users based on load_type
        user_query = get_match_user_query(load_type, time_window_in_minutes)
        if not user_query:
            raise ValueError(f"Unknown argument passed: {load_type}")

        user_df = run_query(iam_graph_operations, user_query)

        # Step 2 - Delete incorrect "REPORTS_TO" relations
        if not user_df.empty:
            delete_result = delete_incorrect_reports(iam_graph_operations, user_df, batch_size)

        # Step 3 - Query users without "REPORTS_TO" relationships
        unrelated_user_query = get_match_user_without_manager_query(load_type, time_window_in_minutes)
        unrelated_user_df = run_query(iam_graph_operations, unrelated_user_query)

        # Step 4 - Create new "REPORTS_TO" relationships
        if not unrelated_user_df.empty:
            create_result = create_reports(iam_graph_operations, unrelated_user_df, batch_size)

    except exceptions.Neo4jError as e:
        is_error_occurred = True
        logging.error(f"Error executing Cypher query: {e}")

    if is_error_occurred:
        logging.error(f"Supervisor hierarchy {load_type} job unsuccessful, please check logs")
    else:
        logging.info(f"Supervisor hierarchy {load_type} job ran successfully with batch_size {batch_size}")

    tracemalloc.stop()

if __name__ == "__main__":
    main()
```

### Changes:
1. **Helper Functions for Queries**: 
   - `get_match_user_query(load_type, time_window_in_minutes)` returns the appropriate query for matching users based on `load_type` (either "full" or "delta").
   - `get_match_user_without_manager_query(load_type, time_window_in_minutes)` does the same for users without the "REPORTS_TO" relationship.

2. **Usage of Helper Functions**:
   - The logic to determine which query to use based on `load_type` is now handled by these helper functions, reducing redundancy and making the code more maintainable.

This refactoring keeps your code clean, organized, and easier to maintain, especially as new queries or query modifications are required in the future.