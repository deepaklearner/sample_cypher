Moving the Cypher queries to a YAML configuration file is an excellent idea! This approach has several advantages:

### **Advantages of Using a YAML Configuration File**:
1. **Separation of Concerns**: It separates configuration from code, making the code more focused and easier to maintain.
2. **Flexibility**: It allows you to change queries or configurations without needing to modify the code itself. You can simply update the YAML file.
3. **Readability**: YAML is a human-readable format, making it easy for non-developers (or less technical users) to understand or modify the queries.
4. **Easier Maintenance**: You can version control the queries separately, and easily adapt them for different environments or use cases.

### **How to Integrate YAML Config File with Your Code**:

1. **Create a YAML Config File for Queries**: Store your queries in the YAML file, categorized by their load type ("full" or "delta").

### Example `queries.yaml`:

```yaml
queries:
  match_user:
    full: |
      MATCH (n:User)-[r:REPORTS_TO]->(m:User)
      WHERE n.managerid IS NOT NULL AND n.managerid <> m.employeeNumber
      RETURN n.employeeNumber AS Employee, n.managerid AS CurrentManager, m.employeeNumber AS RelatedManager

    delta: |
      MATCH (n:User)-[r]-(:ApplicationAccount)
      WHERE datetime(r.lastModifiedOn) > datetime() - duration({{minutes: {time_window_in_minutes}}})
      MATCH (n)-[r:REPORTS_TO]->(m:User)
      WHERE n.managerid IS NOT NULL AND n.managerid <> m.employeeNumber
      RETURN n.employeeNumber AS Employee, n.managerid AS CurrentManager, m.employeeNumber AS RelatedManager

  match_user_without_mngr:
    full: |
      MATCH (n:User)
      WHERE n.managerid IS NOT NULL AND 
            ('Employee' IN labels(n) OR 'Contractor' IN labels(n) OR 'Vendor' IN labels(n)) 
            AND NOT EXISTS((n)-[:REPORTS_TO]->(:User))
      RETURN n.employeeNumber AS Employee, n.managerid AS CurrentManager

    delta: |
      MATCH (n:User)-[r]-(:ApplicationAccount)
      WHERE datetime(r.lastModifiedOn) > datetime() - duration({{minutes: {time_window_in_minutes}}})
      MATCH (n)
      WHERE n.managerid IS NOT NULL AND 
            ('Employee' IN labels(n) OR 'Contractor' IN labels(n) OR 'Vendor' IN labels(n)) 
            AND NOT EXISTS((n)-[:REPORTS_TO]->(:User))
      RETURN n.employeeNumber AS Employee, n.managerid AS CurrentManager
```

2. **Load the YAML Configuration in Your Code**: Use a Python YAML parser to read this configuration file and retrieve the appropriate queries.

### Python Code Integration:

```python
import os
import sys
import pandas as pd
import logging
import tracemalloc
import argparse
import yaml
from datetime import datetime
from src.db_operation.ne4j_operations import IAM_GraphOperations
from sc.utils.helper import read_creds, initialize_main_logger, get_config_stream
from neodi import GraphDatabase, exceptions

# Set up paths
currentdir = os.path.dirname(os.path.realpath(__file__))
parentdir = os.path.dirname(currentdir)
sys.path.append(parentdir)

def load_queries_from_yaml(config_file="queries.yaml"):
    """Load Cypher queries from the YAML configuration file."""
    with open(config_file, 'r') as file:
        queries = yaml.safe_load(file)
    return queries["queries"]

def initialize_configurations(configuration_file="/config/config.yaml"):
    """Load and return configuration and database credentials."""
    logger = initialize_main_logger()
    baseconfigstream = get_config_stream(configuration_file)
    database_configs = read_creds(configuration_file)
    batch_size = baseconfigstream["supervisor_hierarchy_ProjConfig"]["batch_size"]
    time_window_in_minutes = baseconfigstream["supervisor_hierarchy_ProjConfig"]["time_window_in_minutes"]
    return baseconfigstream, database_configs, batch_size, time_window_in_minutes

def run_query(iam_graph_operations, query):
    """Run a query and return results as a DataFrame."""
    with iam_graph_operations.driver.session() as session:
        result = session.run(query)
        return pd.DataFrame([record.values() for record in result], columns=result.keys())

def delete_incorrect_reports(iam_graph_operations, user_df, batch_size):
    """Delete incorrect 'REPORTS_TO' relations."""
    delete_qry = """
    UNWIND $rows AS row
    MATCH (n:User {employeeNumber: row.Employee})-[r:REPORTS_TO]->(m:User {employeeNumber: row.RelatedManager})
    DELETE r
    RETURN count(*) AS total
    """
    return iam_graph_operations.insert_data(delete_qry, user_df, batch_size=batch_size, feature_name="populate_supervisor")

def create_reports(iam_graph_operations, unrelated_user_df, batch_size):
    """Create new 'REPORTS_TO' relations."""
    create_relation_qry = """
    UNWIND $rows AS row
    MATCH (n:User {employeeNumber: row.Employee})
    OPTIONAL MATCH (m:User {employeeNumber: row.CurrentManager})
    WHERE m IS NOT NULL
    MERGE (n)-[:REPORTS_TO]->(m)
    RETURN count(*) AS total
    """
    return iam_graph_operations.insert_data(create_relation_qry, unrelated_user_df, batch_size=batch_size, feature_name="populate_supervisor")

def main():
    tracemalloc.start()

    # Argument parsing
    parser = argparse.ArgumentParser(description="Populate supervisor hierarchy")
    parser.add_argument("--load_type", "-L", type=str, help="Specify the load_type: full/delta")
    parser.add_argument("--log_location", type=str, help="Specify the log location")
    args = parser.parse_args()

    # Initialize configurations
    load_type = args.load_type.lower()
    configuration_file = "/config/config.yaml"
    baseconfigstream, database_configs, batch_size, time_window_in_minutes = initialize_configurations(configuration_file)

    # Load queries from YAML config
    queries = load_queries_from_yaml()

    iam_graph_operations = IAM_GraphOperations(database_configs)
    is_error_occurred = False

    try:
        # Step 1 - Query users based on load_type
        user_query = queries["match_user"].get(load_type)
        if not user_query:
            raise ValueError(f"Unknown argument passed: {load_type}")

        user_df = run_query(iam_graph_operations, user_query)

        # Step 2 - Delete incorrect "REPORTS_TO" relations
        if not user_df.empty:
            delete_result = delete_incorrect_reports(iam_graph_operations, user_df, batch_size)

        # Step 3 - Query users without "REPORTS_TO" relationships
        unrelated_user_query = queries["match_user_without_mngr"].get(load_type)
        unrelated_user_df = run_query(iam_graph_operations, unrelated_user_query)

        # Step 4 - Create new "REPORTS_TO" relationships
        if not unrelated_user_df.empty:
            create_result = create_reports(iam_graph_operations, unrelated_user_df, batch_size)

    except exceptions.Neo4jError as e:
        is_error_occurred = True
        logging.error(f"Error executing Cypher query: {e}")

    if is_error_occurred:
        logging.error(f"Supervisor hierarchy {load_type} job unsuccessful, please check logs")
    else:
        logging.info(f"Supervisor hierarchy {load_type} job ran successfully with batch_size {batch_size}")

    tracemalloc.stop()

if __name__ == "__main__":
    main()
```

### **Changes**:
1. **`load_queries_from_yaml`**:
   - This function loads the queries from the `queries.yaml` configuration file and returns them as a dictionary.

2. **YAML File**:
   - The Cypher queries are now in the `queries.yaml` file. Each query is categorized under `"match_user"` and `"match_user_without_mngr"`, with "full" and "delta" versions.
   
3. **Code Adjustments**:
   - Instead of hardcoding the queries inside the Python code, you now fetch the correct query from the loaded YAML file using `queries["match_user"].get(load_type)` and `queries["match_user_without_mngr"].get(load_type)`.

### **Benefits**:
- **Dynamic**: You can change the queries easily without touching the Python code.
- **Easier Testing**: The queries are decoupled from the code, making unit testing easier.
- **Configuration Flexibility**: You can create different YAML files for different environments (dev, prod) or even for different use cases.
  
### **Next Steps**:
- Ensure that your YAML file is included in your repository and properly versioned.
- Consider adding validation for the YAML file, ensuring that all required queries are present and correctly formatted.