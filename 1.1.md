Hereâ€™s the **complete code** that:

* Connects to Neo4j
* Filters `df` where `userType == 'Employee'`
* For each row:

  * Checks if the Neo4j node with the same `employeeNumber` exists
  * If the node has the `Contractor` label, ensures `recordType == 'Conversion'`
  * If `employmentStatus in ['A', 'L']`, ensures Neo4j has either `Active` or `OnLeave` label
* Collects mismatched rows into `mismatch_df`
* Filters `valid_df` from original `df`
* Saves mismatches to a CSV file

---

### âœ… Full Python Code

```python
import pandas as pd
from neo4j import GraphDatabase

# ==== Neo4j Configuration ====
uri = "bolt://localhost:7687"
username = "neo4j"
password = "your_password"  # Replace with your actual password

driver = GraphDatabase.driver(uri, auth=(username, password))

# ==== Your DataFrame ====
# df = pd.read_csv("your_input_file.csv")  # If loading from a file

# ==== Step 1: Filter Employee Records ====
employee_df = df[df['userType'] == 'Employee']

# ==== Collect Mismatches ====
mismatched_emp_nums = []

# ==== Neo4j Query Function ====
def get_user_labels(tx, emp_num):
    query = """
    MATCH (u:User {employeeNumber: $emp_num})
    RETURN labels(u) AS labels
    """
    result = tx.run(query, emp_num=emp_num)
    record = result.single()
    return record["labels"] if record else []

# ==== Loop Through Rows and Validate ====
with driver.session() as session:
    for _, row in employee_df.iterrows():
        emp_num = row['employeeNumber']
        labels = session.read_transaction(get_user_labels, emp_num)

        # User not found
        if not labels:
            mismatched_emp_nums.append(emp_num)
            continue

        # Contractor but not Conversion
        if 'Contractor' in labels and row['recordType'] != 'Conversion':
            mismatched_emp_nums.append(emp_num)
            continue

        # Check employmentStatus vs Neo4j labels
        if row['employmentStatus'] in ['A', 'L']:
            if not any(l in labels for l in ['Active', 'OnLeave']):
                mismatched_emp_nums.append(emp_num)
                continue

# ==== Build Final DataFrames ====
mismatch_df = df[df['employeeNumber'].isin(mismatched_emp_nums)]
valid_df = df[~df['employeeNumber'].isin(mismatched_emp_nums)]

# ==== Save Mismatches to CSV ====
mismatch_df.to_csv("mismatch_log.csv", index=False)

print("âœ… Done: Mismatches written to 'mismatch_log.csv'")
print(f"âœ… Valid records: {len(valid_df)} | Mismatches: {len(mismatch_df)}")
```

---

### ðŸ’¡ Notes:

* Make sure your Neo4j nodes have a `User` label and a `employeeNumber` property.
* Replace the Neo4j URI and credentials as needed.
* If performance becomes an issue with many rows, batching or parallel reads can help.

Let me know if you want this turned into a function, a CLI script, or integrated with logging for mismatch reasons.
