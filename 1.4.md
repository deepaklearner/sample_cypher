Great — your requirement means we should not **skip the whole row** if **some** owners are invalid. Instead:

- Always create the `Entitlement` node.
- Create `HAS_OWNER` relationships **only** with the valid owners among `owner1`, `owner2`, and `owner3`.
- Report the **invalid owners**, but don’t block node/relationship creation for the valid ones.

---

## ✅ Updated Efficient Design

### Step-by-step:

1. Validate all owner IDs in a vectorized way (same as before).
2. For each row:
   - Identify the **subset of valid owners**.
   - Pass only valid owners to Neo4j.
   - Record any invalid ones for reporting.

---

## ✨ Updated `process_batch()` Code

```python
def process_batch(df):
    owner_columns = ['owner1', 'owner2', 'owner3']
    all_owner_ids = pd.unique(df[owner_columns].values.ravel())
    all_owner_ids = set(filter(None, all_owner_ids))

    valid_owners = get_valid_owners(all_owner_ids)

    error_rows = []

    with neo4j_driver.session() as session:
        for _, row in df.iterrows():
            # Identify valid and invalid owners
            owners = [row['owner1'], row['owner2'], row['owner3']]
            valid = [o for o in owners if o and o in valid_owners]
            invalid = [o for o in owners if o and o not in valid_owners]

            # Always create/update Entitlement and only link to valid owners
            session.write_transaction(create_entitlement_and_links, row, valid)

            if invalid:
                error_rows.append({**row, "invalid_owners": invalid})

    return pd.DataFrame(error_rows) if error_rows else pd.DataFrame()
```

---

## 🔁 Corresponding `create_entitlement_and_links()` Function

```python
def create_entitlement_and_links(tx, row, valid_owner_ids):
    entitlement_id = f"{row['entitlementName']}|{row['targetSystem']}"

    query = """
    MERGE (e:Entitlement {entitlementName: $entitlementName, targetSystem: $targetSystem})
    SET e.entitlementID = $entitlementID,
        e.description = $description,
        e.riskLevel = $riskLevel,
        e.priviledgedAccess = $priviledgedAccess,
        e.entitlementType = $entitlementType

    WITH e
    UNWIND $valid_owners AS owner
    MATCH (u:User {employeeNumber: owner})
    MERGE (e)-[:HAS_OWNER]->(u)
    """

    tx.run(query,
           entitlementName=row['entitlementName'],
           targetSystem=row['targetSystem'],
           entitlementID=entitlement_id,
           description=row['description'],
           riskLevel=row['riskLevel'],
           priviledgedAccess=row['priviledgedAccess'],
           entitlementType=row['entitlementType'],
           valid_owners=valid_owner_ids)
```

---

This design ensures:
- **All entitlements are created**
- **Only valid `User` nodes** are linked via `HAS_OWNER`
- **Partial invalid owners** are captured cleanly in the error report

Would you like this logic extended to handle Neo4j batch writing using `UNWIND` for multiple rows?