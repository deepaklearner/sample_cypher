Sure! Below is your **full, clean, and production-ready script** based on your latest requirements:

---

### ‚úÖ What This Script Does:

* Filters `df` to keep only rows where `userType == 'Employee'`
* Fetches Neo4j labels for all matching `employeeNumber`s using `UNWIND`
* Merges Neo4j labels using an **inner join** (ignoring users not found in Neo4j)
* Applies mismatch checks:

  * Contractor but not "Conversion"
  * Active/OnLeave mismatch for employment status A/L
* Logs mismatches with reasons (only `employeeNumber` and `Reason`)
* Filters valid records (those not in mismatch list)

---

### üß† Assumptions:

* You have a `df` in memory with columns:

  * `employeeNumber`, `userType`, `employmentStatus`, `recordType`
* Neo4j has `User` nodes with `employeeNumber` and various labels (`Contractor`, `Active`, `OnLeave`, etc.)

---

### ‚úÖ Full Code

```python
import pandas as pd
from neo4j import GraphDatabase

# === Neo4j Configuration ===
uri = "bolt://localhost:7687"
username = "neo4j"
password = "your_password"  # Replace with your real password

driver = GraphDatabase.driver(uri, auth=(username, password))

# === Step 1: Filter Employee Users ===
employee_df = df[df['userType'] == 'Employee'].copy()
emp_nums = employee_df['employeeNumber'].tolist()

# === Step 2: Fetch Neo4j Labels Using UNWIND ===
def fetch_user_labels(tx, emp_nums):
    query = """
    UNWIND $empNums AS empNum
    MATCH (u:User {employeeNumber: empNum})
    RETURN empNum AS employeeNumber, labels(u) AS labels
    """
    result = tx.run(query, empNums=emp_nums)
    return [record.data() for record in result]

with driver.session() as session:
    labels_data = session.read_transaction(fetch_user_labels, emp_nums)

labels_df = pd.DataFrame(labels_data)

# === Step 3: Inner Join to Keep Only Users Found in Neo4j ===
merged_df = employee_df.merge(labels_df, on='employeeNumber', how='inner')

# === Step 4: Apply Mismatch Logic ===
# Mismatch 1: Contractor label but not Conversion
cond_contractor_wrong_record = merged_df.apply(
    lambda row: 'Contractor' in row['labels'] and row['recordType'] != 'Conversion',
    axis=1
)

# Mismatch 2: A or L status but not Active/OnLeave label
cond_status_mismatch = merged_df.apply(
    lambda row: (
        row['employmentStatus'] in ['A', 'L'] and
        not any(label in row['labels'] for label in ['Active', 'OnLeave'])
    ),
    axis=1
)

# === Step 5: Add Reason Column ===
merged_df['Reason'] = ""
merged_df.loc[cond_contractor_wrong_record, 'Reason'] = "Contractor label present but recordType is not 'Conversion'"
merged_df.loc[cond_status_mismatch, 'Reason'] = "employmentStatus in ['A','L'] but missing 'Active'/'OnLeave' label in Neo4j"

# === Step 6: Create Mismatch and Valid DataFrames ===
mismatch_df = merged_df[merged_df['Reason'] != ''][['employeeNumber', 'Reason']]
valid_df = df[~df['employeeNumber'].isin(mismatch_df['employeeNumber'])]

# === Step 7: Save Mismatches to CSV ===
mismatch_df.to_csv("mismatch_log.csv", index=False)

print("‚úÖ Mismatch log saved to 'mismatch_log.csv'")
print(f"‚úÖ Valid records: {len(valid_df)}")
print(f"‚ùå Mismatched records: {len(mismatch_df)}")
```

---

### üîß Optional Improvements

* Add this to a function: `def validate_employee_records(df): ...`
* Parameterize output path or Neo4j credentials
* Add logging or summary CSV

---

Let me know if you'd like this wrapped into a reusable function or class ‚Äî or exported as a command-line script or Airflow task.
