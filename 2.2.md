Yes, definitely! You can **avoid the explicit for-loop** by using `groupby` and aggregation operations on the DataFrame to collect reasons per employeeNumber.

Hereâ€™s how to rewrite the `check_new_rejections` function **purely with DataFrame operations** (no explicit Python loops):

---

### Version using DataFrame operations only

```python
def check_new_rejections(df):
    """
    Apply rejection rules and return mismatch_df with columns:
    - employeeNumber
    - Reason (combined if multiple)
    """
    # Rule 1: Contractor + recordType != 'Conversion'
    contractor_mask = df['labels'].apply(lambda labels: 'Contractor' in labels)
    contractor_issue = df[contractor_mask & (df['recordType'] != 'Conversion')]
    contractor_df = contractor_issue[['employeeNumber']].copy()
    contractor_df['Reason'] = "Contractor label present but recordType is not 'Conversion'"

    # Rule 2: employmentStatus in ['A','L'] but missing Active/OnLeave label
    status_mask = df['employmentStatus'].isin(['A', 'L']) & \
                  (~df['labels'].apply(lambda labels: any(l in ['Active', 'OnLeave'] for l in labels)))
    status_issue = df[status_mask]
    status_df = status_issue[['employeeNumber']].copy()
    status_df['Reason'] = "employmentStatus in ['A','L'] but missing 'Active'/'OnLeave' label in Neo4j"

    # Rule 3: hireDate in the future
    if 'hireDate' in df.columns:
        df['hireDate'] = pd.to_datetime(df['hireDate'], errors='coerce')
        future_hires = df[df['hireDate'] > pd.Timestamp.today()]
        future_df = future_hires[['employeeNumber']].copy()
        future_df['Reason'] = "Hire date is in the future"
    else:
        future_df = pd.DataFrame(columns=['employeeNumber', 'Reason'])

    # Combine all mismatches
    combined = pd.concat([contractor_df, status_df, future_df], ignore_index=True)

    # Aggregate reasons by employeeNumber, joining multiple reasons with '; '
    mismatch_df = combined.groupby('employeeNumber')['Reason'].agg('; '.join).reset_index()

    return mismatch_df
```

---

### Explanation

* Build one small DataFrame per rule with `employeeNumber` and corresponding `Reason`.
* Concatenate all mismatches into a single DataFrame.
* Use `groupby` + `agg('; '.join)` to combine reasons for employees with multiple violations.
* Return the final mismatch DataFrame.

---

If you want, I can help integrate this into your full pipeline code!
